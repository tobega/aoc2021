include 'hash'

templates encodeAmphipods
  <='A'> 3!
  <='B'> 5!
  <='C'> 7!
  <='D'> 9!
end encodeAmphipods

composer extractAmphipods
  [<amphipod|not>+]
  rule amphipod: <='A'|='B'|='C'|='D'> -> encodeAmphipods
  rule not: (<~amphipod>)
end extractAmphipods

def input: [$IN::lines] -> [$(3..4)... -> extractAmphipods];

def costs: ['', '', 1"e", '', 10"e", '', 100"e", '', 1000"e"];

def map: ['.', '.', [], '.', [], '.', [], '.', [], '.', '.'];

templates populateMap&{depth:}
  @: $map;
  @(3): $($depth..1:-1; 1);
  @(5): $($depth..1:-1; 2);
  @(7): $($depth..1:-1; 3);
  @(9): $($depth..1:-1; 4);
  {state: $@, cost: $@ -> baseCost&{depth: $depth}} !
end populateMap

templates abs
  <..0> -$ !
  <> $ !
end abs

templates baseCost&{depth:}
  @: $depth * ($depth + 1) ~/ 2 * 1111;
  $ -> \home[i](when <[]> do @:1;
    $ -> \[j](
      when <=$i ?($j <=$@home>)> do  @baseCost: $@baseCost - ($depth - $j + 1) * $costs($); @home: $@home + 1;
      when <=$i> do @baseCost: $@baseCost + ($depth - $j + 1 + 2) * $costs($);
      otherwise @baseCost: $@baseCost + ($depth - $j + 1 + ($-$i -> abs)) * $costs($); \) -> !VOID \home) -> !VOID
  $@!
end baseCost

data 
  amphipod <3..9>,
  state <[<'.'|amphipod|[<amphipod>]>]>,
  cost <"e">



templates generateMoves&{depth:}
  def baseCost: $.cost;
  def basePosition: $.state;
  templates moveHome
    @: $basePosition;
    ..|@($@($)): $@($);
    @($): '.';
    {state: $@, cost: $baseCost} !
  end moveHome
  templates moveDirectly
    @: $basePosition;
    def amphipod: ^@($;last);
    ..|@($amphipod): $amphipod;
    {state: $@, cost: $baseCost} !
  end moveDirectly
  templates moveOut
    def from: $;
    $basePosition -> \[i](
      when <='.' ?([$basePosition($i+1..$from)..., $basePosition($from..$i-1)...] <~[<3..>]>)> do
        @: $basePosition;
        @($i): ^@($from;last);
        {state: $@, cost: $baseCost +
          (($i - $@($i) -> abs) - ($from - $@($i) -> abs) + ($i - $from -> abs) - ($@($i) -> \(<=$from> 2! <> 0!\)))
            * $costs($@($i))} !
    \)... !
  end moveOut
  $basePosition -> \[i](
    when <3.. ?($basePosition($) <~[<~=$>]>) ?([$basePosition($i+1..$)..., $basePosition($..$i-1)...] <~[<3..>]>)> do
      $i -> moveHome !
    when <[<~=$i>](1..) ?($basePosition($(last)) <~[<~=$(last)>]>) ?([$basePosition($i..$(last))..., $basePosition($(last)..$i)...] <~[<3..>]>)> do
      $i -> moveDirectly !
    when <[<~=$i>](1..)> do
      $i -> moveOut !
  \)... !
end generateMoves

templates solve
  def depth: $::length;
  def states: [$ -> populateMap&{depth:$depth}] -> hash/Map&{key: :(state:), value: :()};
  @: {};
  1 -> #
  $@ !
  when <?($@ <={}>)> do
    def lowest: $states::entries -> ..=Min&{by: :(cost:), select: :()};
    $lowest.state -> states::remove -> !VOID
    $lowest -> generateMoves&{depth: $depth} -> \(
      when <{state: <~[<3..>]>} ?($.state(3) <~[<~=3>]>)?($.state(5) <~[<~=5>]>)?($.state(7) <~[<~=7>]>)?($.state(9) <~[<~=9>]>)> do
        @solve: $;
      otherwise
        $ -> states::put -> !VOID
    \) -> !VOID
    1 -> #
end solve
  
source solutionPart1
  $input -> solve !
end solutionPart1

source solutionPart2
  [$input(1), '  #D#C#B#A#' -> extractAmphipods, '  #D#B#A#C#' -> extractAmphipods, $input(2)] -> solve !
end solutionPart2

// String interpolation is to create a empty string value when property does not exist (otherwise the flow would just stop)
'$:'part' -> SYS::property;' -> \(
  when <='part1'|=''> do $solutionPart1 !
  when <='part2'> do $solutionPart2 !
  otherwise 'Unknown part $;' !
\) -> '$;
' -> !OUT::write
